Election Contract
=================
The role of the Election Contract is to build and run elections as well as
ensure the integrity and security of its elections and participating actors. A
number of cryptographic and cryptoeconomic incentivization-disincentivization
schemes are used to maintain election integrity and security.

| Key            | Type                      | Description                                                                                          |
|----------------|---------------------------|------------------------------------------------------------------------------------------------------|
| administrators | Set<Key>                  | A set of public keys associated with each of the administration officials of the election.           |
| DKG_key        | Key                       | A public key generated by election officials using a distributed (threshold) key generation process. |
|                |                           |                                                                                                      |
| name           | String                    | A name for this election (Minimum Wage, Proxy, New Cafeteria Food).                                  |
| description    | String                    | A short description of this election.                                                                |
| choices        | Set<String>               | A set of choices.                                                                                    |
| start_time     | Unsigned Integer          | The start time of the election.                                                                      |
| end_time       | Unsigned Integer          | The end time of the election.                                                                        |
| proxy_time     | Unsigned Integer          | The time all proxy votes have to be in by.                                                           |
| write_in       | Boolean                   | Allow write-in ballots (default: false).                                                             |
|                |                           |                                                                                                      |
| auth_contract  | Contract                  | The authentication contract which contains the set of eligible voters.                               |
| proxy_contract | Contract                  | The proxy contract that applies to this election.                                                    |
|                |                           |                                                                                                      |
| mixnet_nodes   | Set<Key>                  | A set of public keys associated with each of the nodes in the mixnet.                                |
| mixnode_fee    | Unsigned Integer          | The cost associated with becoming a mixnet node.                                                     |
|                |                           |                                                                                                      |
| proxy_ballot   | Map<Key, PlaintextBallot> | A mapping of authenticated proxy voter's public keys to their plaintext ballots.                     |
| voter_ballot   | Map<Key, EncryptedBallot> | A mapping of authenticated voter's public keys to their encrypted ballots.                           |

Functionality 1: Creation
-------------------------
A quorum of election officials form to administer the election contract. The
quorum of election officials register their public keys, perform a DKG process
(publish the public key), and collectively configure the election parameters:
`name`, `description`, `choices`, `start_time`, `end_time`, `proxy_time`,
`proxy_contract`, and `auth_contract`.

Election officials must each individually submit good faith deposits (security
deposits), binders to the election contract which will be forfeited should the
election decryption stage fail. Their binders collectively should sum to enough
ether to reimburse each voter in case of election failure. Should decryption
fail all election official's deposits will be forfeited.

Officials will be rewarded for administering the election process if the
election proceeds without dishonesty.

*TODO: Could we have a bidding process here for the decryption step?*
*TODO: Separate administration from decryption.*

Functionality 2: Mixnet Node Registration
-----------------------------------------
Immediately after the creation of the election contract a bidding process
begins and continues to run until the `end_time` of the election.  Bidders bid
in the bidding process to become nodes in the mixnet. The five highest bidders
are selected as nodes in the mixnet. The starting bid is the cost to run the
election.

The bids act as good faith deposits, binders to the election contract which will
be forfeited should the mixnet node be found guilty of dishonesty.

Election officials are collectively guaranteed up to three nodes in the mixnet.
Each node could of course be a mixnet itself.

8 nodes total? Configurable?

The election officials use a

*TODO: Is an exponential bidding process viable?*

*TODO: We should probably just use the 5 highest bidders. We'll just fall victim
to a Sybil attack if we try to do some partitioning of bidders to allow cheaper
bidders into the game and randomly select from them. It's functionally identical
to the highest bidder winning.*

*TODO: 5 and 5 was a completely arbitrary choice. This probably isn't necessary
for a low stakes election. This should probably be determined based on number of
voters and election administrator configuration.*

Functionality 3: Submit Ballot - Proxy
--------------------------------------
Proxy voters, proxies, can submit plaintext votes using an account
associated with their authorized public key.

After the `proxy_time` has passed proxies can no longer vote using their proxy
ballot. If they have not committed to a proxy ballot before the `proxy_time`
then they are eligible to vote using a voter ballot.

*Note: Proxies can only vote with the votes that have been delegated to them, not
their own vote; e.g., Bob and Charlie both delegate their vote to Alice, Alice
can now vote with a weight of 2 (Bob and Charlie's vote), not 3 (she's lost her
own vote). Further, only proxies can submit votes using proxy ballots. Both of
these properties exist to maintain receipt freedom freedom.

Another way to imagine this is as a tree of voters, where the leaves of the tree
give weight to the vote and the non-leaf nodes influence the direction/choice of
the vote.*

*Note: We need to have a static version of the proxy so that voters cannot
remove their proxy vote and vote again; and so that proxies cannot vote, then
remove their proxy status, then vote again.*

Functionality 4: Submit Ballot - Voter
--------------------------------------
If a voter has not submitted a proxy ballot then a voter may submit a ballot
encrypted using the DKG public key produced by the election administrators.
Ballots are encrypted using an El Gamal encryption scheme which provides
re-encryption and additive homomorphic features.

Functionality 5: Verification
-----------------------------
For a week after the election, verifiers, for a charge, can challenge the mixnet
nodes. If a mixnet node does not respond in a timely fashion to each of the
challenges then the mixnet node is accused of dishonesty and their binder is
forfeit. The dishonest mixnet node is booted from the mixnet and the mixnet is
rerun. 40% of the dishonest node's good faith deposit is given given to the
verifier of the election as a reward for discovering the dishonesty. 30% of the
dishonest node's deposit is burned, and the last 30% of the deposit is put into
the reward pool for the election which is split between election administrators
and honest mixnet nodes.

*TODO: Should voters be given some of the reward?*

The verification functionality is broken into two parts: commitment,
verification, and collection.

### Commmit
The verifier commits to challenging a mixnet node by submitting a transaction
containing a hash of verification challenge parameters, the node that they wish
to challenge, a reward address, and a deposit (enough gas/ether to verify the
transaction on chain). An immutable mapping is created that links the hash of
the verification parameters to the reward address.

### Verify
After the verifier is sufficiently convinced that their hash is set in the
blockchain they can activate the verification process by revealing their
challenge parameters, a portion of the mix node proof, and the necessary merkle
tree elements to confirm the legitimacy. The verification parameters are
computed against the mixnet node's published proof to detect dishonesty. The
previously mentioned mixnet node punishment occurs if dishonesty is discovered.

*Note: If they verifier never reveals their verification parameters then their
deposit is forfeit and added to the contract reward pool.*

Final Notes
-----------
Receipt freedom might be compromised if an organization large enough proxies
their votes individually to people they wish to coerce or vote buy from.

Mixnode attack to delay election.

Verifier attack to refund money in mixnode delay attack.
